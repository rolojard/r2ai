<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R2D2 Enhanced Control Dashboard</title>

    <!-- Auth Token Initialization (CRITICAL FIX) -->
    <script>
        console.log('üîê Initializing authentication...');

        // Strategy 1: Retrieve from server endpoint
        // Strategy 2: Fall back to localStorage
        // Strategy 3: Use test token for development

        window.R2D2_AUTH_TOKEN = null;
        window.R2D2_CSRF_TOKEN = null;

        // Function to fetch both auth and CSRF tokens from server
        async function initializeTokens() {
            try {
                // Fetch auth token from server
                const authResponse = await fetch('http://localhost:8770/api/auth/token', {
                    credentials: 'include'
                });

                if (authResponse.ok) {
                    const authData = await authResponse.json();
                    window.R2D2_AUTH_TOKEN = authData.token;
                    console.log('‚úÖ Auth token from server:', authData.token.substring(0, 8) + '...');
                    localStorage.setItem('r2d2_auth_token', authData.token);
                } else {
                    throw new Error('Auth token fetch failed');
                }

                // Fetch CSRF token from server
                const csrfResponse = await fetch('http://localhost:8770/api/csrf/token', {
                    method: 'POST',
                    credentials: 'include'
                });

                if (csrfResponse.ok) {
                    const csrfData = await csrfResponse.json();
                    window.R2D2_CSRF_TOKEN = csrfData.csrf_token;
                    console.log('‚úÖ CSRF token from server:', csrfData.csrf_token.substring(0, 16) + '...');
                    sessionStorage.setItem('r2d2_csrf_token', csrfData.csrf_token);
                } else {
                    console.warn('‚ö†Ô∏è CSRF token fetch failed, will retry on POST');
                }
            } catch (err) {
                console.warn('‚ö†Ô∏è Could not fetch tokens from server:', err.message);

                // Fall back to localStorage for auth token
                const stored = localStorage.getItem('r2d2_auth_token');
                if (stored) {
                    window.R2D2_AUTH_TOKEN = stored;
                    console.log('‚úÖ Auth token from localStorage:', stored.substring(0, 8) + '...');
                } else {
                    // Development fallback
                    window.R2D2_AUTH_TOKEN = 'development-token-for-testing';
                    console.warn('‚ö†Ô∏è Using development token (no server response)');
                }
            }
        }

        // Initialize tokens immediately
        initializeTokens();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            min-height: 100vh;
            padding: 20px;
        }

        /* DISNEY-LEVEL Professional Header with Star Wars Theming */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg,
                rgba(30, 41, 59, 0.95) 0%,
                rgba(15, 23, 42, 0.95) 50%,
                rgba(30, 41, 59, 0.95) 100%);
            border-radius: 20px;
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
            overflow: hidden;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #3b82f6, #10b981, #f59e0b, #3b82f6);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            z-index: -1;
            border-radius: 18px;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            background: linear-gradient(135deg, #3b82f6, #10b981, #f59e0b);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
            animation: textGlow 3s ease-in-out infinite alternate;
        }

        @keyframes textGlow {
            from { filter: drop-shadow(0 0 5px rgba(59, 130, 246, 0.3)); }
            to { filter: drop-shadow(0 0 15px rgba(16, 185, 129, 0.5)); }
        }

        .header p {
            font-size: 1.1rem;
            color: #cbd5e1;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* PROFESSIONAL-GRADE Control Panels with Advanced Styling */
        .control-panel {
            background: linear-gradient(135deg,
                rgba(30, 41, 59, 0.85) 0%,
                rgba(15, 23, 42, 0.9) 100%);
            border: 1px solid rgba(51, 65, 85, 0.6);
            border-radius: 18px;
            padding: 24px;
            backdrop-filter: blur(16px) saturate(180%);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.5), transparent);
        }

        .control-panel:hover {
            transform: translateY(-2px);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(59, 130, 246, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* DISNEY-LEVEL Panel Headers */
        .control-panel h2 {
            color: #10b981;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.25rem;
            font-weight: 700;
            position: relative;
            padding-bottom: 8px;
        }

        .control-panel h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, #10b981, transparent);
            border-radius: 2px;
        }

        /* PROFESSIONAL Vision Feed with Enhanced Styling */
        .vision-feed {
            grid-column: 1 / -1;
            background: linear-gradient(135deg,
                rgba(15, 23, 42, 0.95) 0%,
                rgba(30, 41, 59, 0.9) 100%);
            border: 2px solid transparent;
            background-clip: padding-box;
            border-radius: 20px;
            padding: 24px;
            min-height: 420px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .vision-feed::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg,
                rgba(59, 130, 246, 0.1),
                rgba(16, 185, 129, 0.1),
                rgba(245, 158, 11, 0.05));
            z-index: -1;
            border-radius: 18px;
        }

        /* PREMIUM Vision Frame with Professional Styling */
        .vision-frame {
            width: 100%;
            height: 360px;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
            border-radius: 16px;
            border: 2px solid #334155;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 1.1rem;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow:
                inset 0 2px 8px rgba(0, 0, 0, 0.6),
                0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .vision-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(45deg, transparent 49%, rgba(59, 130, 246, 0.1) 50%, transparent 51%),
                linear-gradient(-45deg, transparent 49%, rgba(16, 185, 129, 0.1) 50%, transparent 51%);
            background-size: 20px 20px;
            opacity: 0.3;
            animation: scanLines 2s linear infinite;
        }

        @keyframes scanLines {
            0% { transform: translateX(-20px); }
            100% { transform: translateX(20px); }
        }

        .vision-frame.active {
            border-color: #10b981;
            box-shadow:
                inset 0 2px 8px rgba(0, 0, 0, 0.6),
                0 4px 16px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(16, 185, 129, 0.3);
        }

        .vision-frame img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .servo-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .servo-group {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #475569;
        }

        .servo-group h3 {
            color: #f59e0b;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .servo-control {
            margin-bottom: 15px;
        }

        .servo-control label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #cbd5e1;
        }

        .servo-slider {
            width: 100%;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        .servo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
        }

        .servo-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .servo-value {
            float: right;
            color: #10b981;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        /* DISNEY-LEVEL Professional Control Buttons */
        .control-button {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 16px rgba(59, 130, 246, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .control-button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow:
                0 12px 32px rgba(59, 130, 246, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .control-button:hover::before {
            left: 100%;
        }

        .control-button:active {
            transform: translateY(-1px) scale(1.01);
            box-shadow:
                0 6px 20px rgba(59, 130, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .control-button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .control-button.danger {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        }

        .control-button.danger:hover {
            box-shadow:
                0 12px 32px rgba(220, 38, 38, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .control-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .control-button.success:hover {
            box-shadow:
                0 12px 32px rgba(16, 185, 129, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .control-button.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .control-button.warning:hover {
            box-shadow:
                0 12px 32px rgba(245, 158, 11, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .status-card {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #475569;
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #10b981;
            display: block;
            margin-top: 5px;
        }

        /* ENHANCED Character Detection Display */
        .character-detection {
            background: linear-gradient(135deg,
                rgba(16, 185, 129, 0.15) 0%,
                rgba(16, 185, 129, 0.05) 100%);
            border: 2px solid rgba(16, 185, 129, 0.6);
            padding: 18px;
            border-radius: 16px;
            margin-top: 16px;
            display: none;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(8px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 16px rgba(16, 185, 129, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .character-detection::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #10b981, transparent);
            animation: scanningLine 2s ease-in-out infinite;
        }

        @keyframes scanningLine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .character-detection.active {
            display: block;
            animation: slideInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .character-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #10b981;
            margin-bottom: 5px;
        }

        .character-confidence {
            color: #fbbf24;
            font-weight: 600;
        }

        /* PROFESSIONAL Emergency Stop Button with High Visibility */
        .emergency-stop {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 1000;
        }

        .emergency-stop button {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            border: 2px solid rgba(220, 38, 38, 0.3);
            padding: 16px 28px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 800;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 24px rgba(220, 38, 38, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: emergencyPulse 2s ease-in-out infinite;
        }

        .emergency-stop button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
            transform: scale(0);
            transition: transform 0.3s ease;
            border-radius: 50px;
        }

        .emergency-stop button:hover::before {
            transform: scale(1);
        }

        .emergency-stop button:hover {
            transform: scale(1.05);
            box-shadow:
                0 12px 32px rgba(220, 38, 38, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            animation: emergencyPulse 1s ease-in-out infinite;
        }

        @keyframes emergencyPulse {
            0% {
                box-shadow:
                    0 8px 24px rgba(220, 38, 38, 0.4),
                    0 0 0 0 rgba(220, 38, 38, 0.7),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
            70% {
                box-shadow:
                    0 8px 24px rgba(220, 38, 38, 0.4),
                    0 0 0 15px rgba(220, 38, 38, 0),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
            100% {
                box-shadow:
                    0 8px 24px rgba(220, 38, 38, 0.4),
                    0 0 0 0 rgba(220, 38, 38, 0),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* PROFESSIONAL Connection Status Indicator */
        .connection-status {
            position: fixed;
            top: 24px;
            left: 24px;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 0.9rem;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            z-index: 1000;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 4px 16px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .connection-status.connected {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow:
                0 4px 16px rgba(16, 185, 129, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .connection-status::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
        }

        .connection-status.connected::before {
            animation: connectionPulse 2s ease-in-out infinite;
        }

        @keyframes connectionPulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.6; transform: translateY(-50%) scale(1.2); }
        }

        .audio-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .audio-button {
            background: linear-gradient(45deg, #f59e0b, #d97706);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .audio-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3);
        }

        /* Behavioral Intelligence Styles */
        .behavior-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 10px;
            border: 1px solid #475569;
        }

        .behavior-section h3 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Personality Mode Styles */
        .personality-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .personality-button {
            background: linear-gradient(45deg, #374151, #4b5563);
            color: #d1d5db;
            border: 2px solid #6b7280;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }

        .personality-button:hover {
            background: linear-gradient(45deg, #4b5563, #6b7280);
            border-color: #22c55e;
            transform: translateY(-2px);
        }

        .personality-button.active {
            background: linear-gradient(45deg, #16a34a, #22c55e);
            border-color: #22c55e;
            color: #fff;
            box-shadow: 0 4px 20px rgba(34, 197, 94, 0.3);
        }

        /* Mode Toggle Styles */
        .mode-toggle {
            display: flex;
            gap: 10px;
        }

        .toggle-button {
            flex: 1;
            background: linear-gradient(45deg, #374151, #4b5563);
            color: #d1d5db;
            border: 2px solid #6b7280;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .toggle-button:hover {
            border-color: #3b82f6;
            background: linear-gradient(45deg, #1e40af, #3b82f6);
        }

        .toggle-button.active {
            background: linear-gradient(45deg, #1d4ed8, #3b82f6);
            border-color: #3b82f6;
            color: #fff;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }

        /* Sensitivity Controls */
        .sensitivity-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sensitivity-item label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #cbd5e1;
        }

        .sensitivity-value {
            float: right;
            color: #22c55e;
            font-weight: bold;
        }

        .sensitivity-slider {
            width: 100%;
            height: 6px;
            background: #374151;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .sensitivity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #22c55e;
            border-radius: 50%;
            cursor: pointer;
        }

        .sensitivity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #22c55e;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Quick Response Grid */
        .response-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .response-button {
            background: linear-gradient(45deg, #1f2937, #374151);
            color: #f3f4f6;
            border: 2px solid #4b5563;
            padding: 16px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 80px;
            justify-content: center;
        }

        .response-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .response-button span {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .response-button small {
            font-size: 0.75rem;
            color: #9ca3af;
            line-height: 1.2;
        }

        /* Response Button Colors */
        .response-button.curious { border-color: #f59e0b; }
        .response-button.curious:hover { border-color: #f59e0b; box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3); }

        .response-button.excited { border-color: #ec4899; }
        .response-button.excited:hover { border-color: #ec4899; box-shadow: 0 8px 25px rgba(236, 72, 153, 0.3); }

        .response-button.worried { border-color: #ef4444; }
        .response-button.worried:hover { border-color: #ef4444; box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3); }

        .response-button.playful { border-color: #8b5cf6; }
        .response-button.playful:hover { border-color: #8b5cf6; box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3); }

        .response-button.greeting { border-color: #10b981; }
        .response-button.greeting:hover { border-color: #10b981; box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3); }

        .response-button.alert { border-color: #f97316; }
        .response-button.alert:hover { border-color: #f97316; box-shadow: 0 8px 25px rgba(249, 115, 22, 0.3); }

        .response-button.celebration { border-color: #06b6d4; }
        .response-button.celebration:hover { border-color: #06b6d4; box-shadow: 0 8px 25px rgba(6, 182, 212, 0.3); }

        .response-button.sleepy { border-color: #64748b; }
        .response-button.sleepy:hover { border-color: #64748b; box-shadow: 0 8px 25px rgba(100, 116, 139, 0.3); }

        /* Queue Controls */
        .queue-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .queue-display {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #475569;
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .queue-header h4 {
            color: #22c55e;
            margin: 0;
        }

        .queue-buttons {
            display: flex;
            gap: 8px;
        }

        .queue-btn {
            background: #374151;
            color: #d1d5db;
            border: 1px solid #6b7280;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .queue-btn:hover {
            background: #4b5563;
            border-color: #9ca3af;
        }

        .queue-btn.danger {
            background: #dc2626;
            border-color: #ef4444;
        }

        .queue-btn.danger:hover {
            background: #ef4444;
        }

        .queue-list {
            min-height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .queue-empty {
            color: #6b7280;
            text-align: center;
            font-style: italic;
            padding: 20px;
        }

        .demo-controls h4 {
            color: #3b82f6;
            margin-bottom: 15px;
        }

        .demo-grid {
            display: grid;
            gap: 12px;
        }

        .demo-button {
            background: linear-gradient(45deg, #1e3a8a, #3b82f6);
            color: white;
            border: none;
            padding: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .demo-button small {
            display: block;
            margin-top: 6px;
            opacity: 0.8;
            font-size: 0.8rem;
        }

        /* Behavioral Status Grid */
        .behavior-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .behavior-card {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            transition: all 0.3s ease;
        }

        .behavior-card.active-state {
            border-color: #22c55e;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
        }

        .behavior-icon {
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            flex-shrink: 0;
        }

        .behavior-info {
            flex: 1;
        }

        .behavior-info h4 {
            color: #f1f5f9;
            margin: 0 0 8px 0;
            font-size: 0.9rem;
        }

        .behavior-name {
            color: #22c55e;
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }

        .behavior-progress {
            background: rgba(0, 0, 0, 0.3);
            height: 4px;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #22c55e, #16a34a);
            height: 100%;
            width: 35%;
            transition: width 0.3s ease;
        }

        .environment-stats, .env-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .env-stat span {
            color: #cbd5e1;
        }

        .env-stat strong {
            color: #22c55e;
        }

        .audio-status, .audio-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .audio-current {
            color: #22c55e;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .servo-activity {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .servo-indicator {
            display: flex;
            gap: 8px;
        }

        .servo-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .servo-dot.active {
            background: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);
        }

        .servo-dot.idle {
            background: #374151;
            border: 1px solid #6b7280;
        }

        .character-panel {
            background: rgba(15, 23, 42, 0.4);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #475569;
            margin-top: 20px;
        }

        .character-panel h4 {
            color: #f59e0b;
            margin: 0 0 15px 0;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }

        .character-placeholder {
            color: #6b7280;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        /* PROFESSIONAL Loading States and Smooth Transitions */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(59, 130, 246, 0.2);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* System Status Indicators */
        .system-health-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc2626;
            transition: all 0.3s ease;
        }

        .system-health-indicator.healthy {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        .system-health-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }

        .system-health-indicator.error {
            background: #dc2626;
            box-shadow: 0 0 8px rgba(220, 38, 38, 0.4);
            animation: errorBlink 1s ease-in-out infinite;
        }

        @keyframes errorBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Professional Toast Notifications */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 24px;
            z-index: 1000;
            max-width: 400px;
        }

        .toast {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 8px;
            color: #f8fafc;
            font-size: 0.9rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            transform: translateX(100%);
            animation: slideInToast 0.3s ease-out forwards;
        }

        @keyframes slideInToast {
            to { transform: translateX(0); }
        }

        .toast.success {
            border-color: rgba(16, 185, 129, 0.5);
        }

        .toast.warning {
            border-color: rgba(245, 158, 11, 0.5);
        }

        .toast.error {
            border-color: rgba(220, 38, 38, 0.5);
        }

        /* Accessibility Enhancements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High Contrast Mode Support */
        @media (prefers-contrast: high) {
            .control-panel {
                border-width: 2px;
                border-color: #ffffff;
            }

            .control-button {
                border: 2px solid #ffffff;
            }
        }

        /* Focus Styles for Accessibility */
        .control-button:focus,
        .personality-button:focus,
        .response-button:focus,
        .servo-slider:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        /* PROFESSIONAL Responsive Design for All Devices */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .header h1 {
                font-size: 2.2rem;
            }

            .control-panel {
                padding: 20px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 12px;
            }

            .header {
                padding: 20px;
                margin-bottom: 20px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .header p {
                font-size: 0.95rem;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .control-panel {
                padding: 16px;
                border-radius: 12px;
            }

            .vision-frame {
                height: 280px;
            }

            .servo-controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .button-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .control-button {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            .personality-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .personality-button {
                padding: 10px 12px;
                font-size: 0.8rem;
            }

            .response-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .response-button {
                padding: 12px 10px;
                min-height: 70px;
            }

            .queue-controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .behavior-status-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .status-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .emergency-stop {
                top: 12px;
                right: 12px;
            }

            .emergency-stop button {
                padding: 12px 20px;
                font-size: 1rem;
            }

            .connection-status {
                top: 12px;
                left: 12px;
                padding: 8px 16px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.6rem;
            }

            .personality-grid {
                grid-template-columns: 1fr;
            }

            .status-grid {
                grid-template-columns: 1fr;
            }

            .demo-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Professional System Controls -->
    <div class="emergency-stop">
        <button onclick="emergencyStop()" aria-label="Emergency Stop All Systems">
            üö® EMERGENCY STOP
        </button>
    </div>

    <div class="connection-status" id="connectionStatus" aria-live="polite">
        Initializing...
    </div>

    <!-- Toast Notification Container -->
    <div class="toast-container" id="toastContainer" aria-live="polite" aria-label="System notifications"></div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay" aria-hidden="true">
        <div class="loading-spinner" aria-label="Loading"></div>
    </div>

    <div class="header" role="banner">
        <h1>ü§ñ R2D2 Enhanced Control Dashboard</h1>
        <p>Real-time Character Recognition ‚Ä¢ Servo Control ‚Ä¢ Behavioral Intelligence</p>
        <div class="system-health-indicator" id="overallSystemHealth"
             aria-label="Overall system health indicator"
             title="System Status: Initializing"></div>
    </div>

    <div class="main-grid">
        <!-- Vision Feed -->
        <div class="vision-feed">
            <h2>üé• Live Vision Feed with Character Recognition</h2>
            <div class="vision-frame" id="visionFrame">
                <img id="videoFeed" style="width: 100%; height: 100%; object-fit: contain; display: none;" alt="Live video feed">
                <div id="noVideo" style="display: flex; align-items: center; justify-content: center; height: 100%; color: #64748b; font-size: 18px;">
                    <div>
                        <div>üì∑ Connecting to vision system...</div>
                        <div style="font-size: 14px; margin-top: 10px;">Waiting for vision system</div>
                    </div>
                </div>
            </div>
            <div class="character-detection" id="characterDetection">
                <div class="character-name" id="characterName">Unknown Character</div>
                <div class="character-confidence" id="characterConfidence">Confidence: 0%</div>
                <div id="characterReaction">R2D2 Reaction: Neutral</div>
            </div>
        </div>

        <!-- Servo Controls -->
        <div class="control-panel">
            <h2>üîß Servo Control System</h2>
            <div class="servo-controls">
                <!-- Dome Controls -->
                <div class="servo-group">
                    <h3>Dome Movement</h3>
                    <div class="servo-control">
                        <label for="domeRotation">Dome Rotation <span class="servo-value" id="domeRotationValue">1500¬µs</span></label>
                        <input type="range" id="domeRotation" class="servo-slider" min="1000" max="2000" value="1500" oninput="updateServo(0, this.value)">
                    </div>
                    <div class="servo-control">
                        <label for="headTilt">Head Tilt <span class="servo-value" id="headTiltValue">1500¬µs</span></label>
                        <input type="range" id="headTilt" class="servo-slider" min="1200" max="1800" value="1500" oninput="updateServo(1, this.value)">
                    </div>
                </div>

                <!-- Panel Controls -->
                <div class="servo-group">
                    <h3>Dome Panels</h3>
                    <div class="servo-control">
                        <label for="frontPanel">Front Panel <span class="servo-value" id="frontPanelValue">1000¬µs</span></label>
                        <input type="range" id="frontPanel" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(6, this.value)">
                    </div>
                    <div class="servo-control">
                        <label for="leftPanel">Left Panel <span class="servo-value" id="leftPanelValue">1000¬µs</span></label>
                        <input type="range" id="leftPanel" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(7, this.value)">
                    </div>
                    <div class="servo-control">
                        <label for="rightPanel">Right Panel <span class="servo-value" id="rightPanelValue">1000¬µs</span></label>
                        <input type="range" id="rightPanel" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(8, this.value)">
                    </div>
                </div>

                <!-- Utility Controls -->
                <div class="servo-group">
                    <h3>Utility Systems</h3>
                    <div class="servo-control">
                        <label for="periscope">Periscope <span class="servo-value" id="periscopeValue">1000¬µs</span></label>
                        <input type="range" id="periscope" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(2, this.value)">
                    </div>
                    <div class="servo-control">
                        <label for="leftArm">Left Utility Arm <span class="servo-value" id="leftArmValue">1000¬µs</span></label>
                        <input type="range" id="leftArm" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(4, this.value)">
                    </div>
                    <div class="servo-control">
                        <label for="rightArm">Right Utility Arm <span class="servo-value" id="rightArmValue">1000¬µs</span></label>
                        <input type="range" id="rightArm" class="servo-slider" min="1000" max="1800" value="1000" oninput="updateServo(5, this.value)">
                    </div>
                </div>
            </div>

            <div class="button-grid">
                <button class="control-button success" onclick="homeAllServos()">üè† Home All</button>
                <button class="control-button" onclick="testServos()">üîß Test Servos</button>
                <button class="control-button danger" onclick="servoEmergencyStop()">‚õî Stop Servos</button>
            </div>
        </div>

        <!-- Audio Controls -->
        <div class="control-panel">
            <h2>üîä R2D2 Audio System</h2>
            <div class="audio-controls">
                <button class="audio-button" onclick="playSound('beep_happy')">üòä Happy Beep</button>
                <button class="audio-button" onclick="playSound('beep_sad')">üò¢ Sad Beep</button>
                <button class="audio-button" onclick="playSound('beep_excited')">ü§© Excited</button>
                <button class="audio-button" onclick="playSound('beep_worried')">üò∞ Worried</button>
                <button class="audio-button" onclick="playSound('whistle')">üéµ Whistle</button>
                <button class="audio-button" onclick="playSound('scream')">üò± Scream</button>
                <button class="audio-button" onclick="playSound('chirp')">üê¶ Chirp</button>
                <button class="audio-button" onclick="playSound('spin')">üåÄ Spin Sound</button>
            </div>

            <div class="button-grid">
                <button class="control-button" onclick="playCharacterGreeting()">üëã Character Greeting</button>
                <button class="control-button" onclick="playRandomSound()">üé≤ Random Sound</button>
                <button class="control-button danger" onclick="stopAllAudio()">üîá Stop Audio</button>
            </div>
        </div>

        <!-- Behavioral Intelligence Control Panel -->
        <div class="control-panel">
            <h2>üß† R2D2 Behavioral Intelligence</h2>

            <!-- Personality Mode Selector -->
            <div class="behavior-section">
                <h3>Personality Mode</h3>
                <div class="personality-grid">
                    <button class="personality-button active" data-mode="curious" onclick="setPersonalityMode('curious')">
                        ü§î Curious
                    </button>
                    <button class="personality-button" data-mode="excited" onclick="setPersonalityMode('excited')">
                        ü§© Excited
                    </button>
                    <button class="personality-button" data-mode="cautious" onclick="setPersonalityMode('cautious')">
                        ‚ö†Ô∏è Cautious
                    </button>
                    <button class="personality-button" data-mode="playful" onclick="setPersonalityMode('playful')">
                        üòÑ Playful
                    </button>
                    <button class="personality-button" data-mode="protective" onclick="setPersonalityMode('protective')">
                        üõ°Ô∏è Protective
                    </button>
                    <button class="personality-button" data-mode="maintenance" onclick="setPersonalityMode('maintenance')">
                        üîß Maintenance
                    </button>
                </div>
            </div>

            <!-- Control Mode Toggle -->
            <div class="behavior-section">
                <h3>Control Mode</h3>
                <div class="mode-toggle">
                    <button class="toggle-button active" id="autoMode" onclick="setControlMode('auto')">ü§ñ Autonomous</button>
                    <button class="toggle-button" id="manualMode" onclick="setControlMode('manual')">üéÆ Manual</button>
                </div>
            </div>

            <!-- Environmental Sensitivity -->
            <div class="behavior-section">
                <h3>Environmental Sensitivity</h3>
                <div class="sensitivity-controls">
                    <div class="sensitivity-item">
                        <label for="motionSensitivity">Motion Detection <span class="sensitivity-value" id="motionValue">75%</span></label>
                        <input type="range" id="motionSensitivity" class="sensitivity-slider" min="0" max="100" value="75" oninput="updateSensitivity('motion', this.value)">
                    </div>
                    <div class="sensitivity-item">
                        <label for="noiseSensitivity">Audio Response <span class="sensitivity-value" id="noiseValue">60%</span></label>
                        <input type="range" id="noiseSensitivity" class="sensitivity-slider" min="0" max="100" value="60" oninput="updateSensitivity('noise', this.value)">
                    </div>
                    <div class="sensitivity-item">
                        <label for="proximySensitivity">Proximity Awareness <span class="sensitivity-value" id="proximityValue">90%</span></label>
                        <input type="range" id="proximySensitivity" class="sensitivity-slider" min="0" max="100" value="90" oninput="updateSensitivity('proximity', this.value)">
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Response Panel -->
        <div class="control-panel">
            <h2>‚ö° Quick Behavior Responses</h2>
            <div class="response-grid">
                <button class="response-button curious" onclick="triggerQuickResponse('curious')">
                    ü§î <span>Curious</span>
                    <small>Head tilt + investigating beeps</small>
                </button>
                <button class="response-button excited" onclick="triggerQuickResponse('excited')">
                    ü§© <span>Excited</span>
                    <small>Dome spin + happy chirps</small>
                </button>
                <button class="response-button worried" onclick="triggerQuickResponse('worried')">
                    üò∞ <span>Worried</span>
                    <small>Head shake + concerned beeps</small>
                </button>
                <button class="response-button playful" onclick="triggerQuickResponse('playful')">
                    üòÑ <span>Playful</span>
                    <small>Panels open + playful sounds</small>
                </button>
                <button class="response-button greeting" onclick="triggerQuickResponse('greeting')">
                    üëã <span>Greeting</span>
                    <small>Nod + friendly whistle</small>
                </button>
                <button class="response-button alert" onclick="triggerQuickResponse('alert')">
                    üö® <span>Alert</span>
                    <small>Rapid dome turn + alert tone</small>
                </button>
                <button class="response-button celebration" onclick="triggerQuickResponse('celebration')">
                    üéâ <span>Celebration</span>
                    <small>All panels + victory beeps</small>
                </button>
                <button class="response-button sleepy" onclick="triggerQuickResponse('sleepy')">
                    üò¥ <span>Sleepy</span>
                    <small>Slow movements + yawn sounds</small>
                </button>
            </div>
        </div>

        <!-- Behavior Queue Management -->
        <div class="control-panel">
            <h2>üìã Behavior Queue</h2>
            <div class="queue-controls">
                <div class="queue-display">
                    <div class="queue-header">
                        <h4>Queued Behaviors <span id="queueCount">(0)</span></h4>
                        <div class="queue-buttons">
                            <button class="queue-btn" onclick="pauseQueue()">‚è∏Ô∏è Pause</button>
                            <button class="queue-btn" onclick="resumeQueue()">‚ñ∂Ô∏è Resume</button>
                            <button class="queue-btn danger" onclick="clearQueue()">üóëÔ∏è Clear</button>
                        </div>
                    </div>
                    <div class="queue-list" id="behaviorQueue">
                        <div class="queue-empty">No behaviors queued</div>
                    </div>
                </div>

                <div class="demo-controls">
                    <h4>Demo Sequences</h4>
                    <div class="demo-grid">
                        <button class="demo-button" onclick="startDemo('convention')">
                            üé™ Convention Demo
                            <small>5-minute crowd pleasing routine</small>
                        </button>
                        <button class="demo-button" onclick="startDemo('patrol')">
                            üö∂ Security Patrol
                            <small>Autonomous area scanning</small>
                        </button>
                        <button class="demo-button" onclick="startDemo('interactive')">
                            ü§ù Interactive Mode
                            <small>Respond to people naturally</small>
                        </button>
                        <button class="demo-button" onclick="startDemo('maintenance')">
                            üîß Self-Check
                            <small>System diagnostics routine</small>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legacy Behavior Patterns -->
        <div class="control-panel">
            <h2>üé≠ Classic Behavior Patterns</h2>
            <div class="button-grid">
                <button class="control-button success" onclick="executePattern('excited_greeting')">üéâ Excited Greeting</button>
                <button class="control-button" onclick="executePattern('head_nod_yes')">‚úÖ Head Nod Yes</button>
                <button class="control-button" onclick="executePattern('head_shake_no')">‚ùå Head Shake No</button>
                <button class="control-button" onclick="executePattern('cautious_behavior')">‚ö†Ô∏è Cautious Mode</button>
                <button class="control-button" onclick="executePattern('idle_behavior')">üò¥ Idle Behavior</button>
                <button class="control-button" onclick="executePattern('scan_area')">üîç Scan Area</button>
            </div>
        </div>

        <!-- Behavioral Status & Environmental Awareness -->
        <div class="control-panel">
            <h2>üß† R2D2 Behavioral Status</h2>
            <div class="behavior-status-grid">
                <div class="behavior-card active-state">
                    <div class="behavior-icon">ü§ñ</div>
                    <div class="behavior-info">
                        <h4>Current Behavior</h4>
                        <div class="behavior-name" id="currentBehavior">Idle - Curious</div>
                        <div class="behavior-progress">
                            <div class="progress-bar" id="behaviorProgress"></div>
                        </div>
                        <small id="behaviorDuration">00:00 / 00:00</small>
                    </div>
                </div>

                <div class="behavior-card">
                    <div class="behavior-icon">üëÅÔ∏è</div>
                    <div class="behavior-info">
                        <h4>Environmental Awareness</h4>
                        <div class="environment-stats">
                            <div class="env-stat">
                                <span>People Detected:</span>
                                <strong id="peopleCount">0</strong>
                            </div>
                            <div class="env-stat">
                                <span>Motion Level:</span>
                                <strong id="motionLevel">Low</strong>
                            </div>
                            <div class="env-stat">
                                <span>Noise Level:</span>
                                <strong id="noiseLevel">Quiet</strong>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="behavior-card">
                    <div class="behavior-icon">üéµ</div>
                    <div class="behavior-info">
                        <h4>Audio Activity</h4>
                        <div class="audio-status" id="audioActivity">
                            <div class="audio-item">
                                <span class="audio-current">Ready</span>
                                <small>No active sounds</small>
                            </div>
                        </div>
                        <div class="audio-queue" id="audioQueue">
                            <small>Queue: Empty</small>
                        </div>
                    </div>
                </div>

                <div class="behavior-card">
                    <div class="behavior-icon">üéõÔ∏è</div>
                    <div class="behavior-info">
                        <h4>Servo Activity</h4>
                        <div class="servo-activity">
                            <div class="servo-indicator">
                                <div class="servo-dot active" title="Dome Rotation"></div>
                                <div class="servo-dot idle" title="Head Tilt"></div>
                                <div class="servo-dot idle" title="Periscope"></div>
                                <div class="servo-dot idle" title="Left Arm"></div>
                                <div class="servo-dot idle" title="Right Arm"></div>
                            </div>
                            <div class="servo-stats">
                                <small>Active: <span id="activeServos">1/8</span></small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Character Recognition Panel -->
            <div class="character-panel" id="characterPanel">
                <h4>üé≠ Character Recognition</h4>
                <div class="character-grid" id="detectedCharacters">
                    <div class="character-placeholder">
                        üë§ No characters detected
                    </div>
                </div>
            </div>
        </div>

        <!-- System Performance Status -->
        <div class="control-panel">
            <h2>üìä System Performance</h2>
            <div class="status-grid">
                <div class="status-card">
                    <div>Vision System</div>
                    <span class="status-value" id="visionStatus">Disconnected</span>
                </div>
                <div class="status-card">
                    <div>Behavioral Engine</div>
                    <span class="status-value" id="behaviorStatus">Initializing</span>
                </div>
                <div class="status-card">
                    <div>Servo Controller</div>
                    <span class="status-value" id="servoStatus">Unknown</span>
                </div>
                <div class="status-card">
                    <div>Audio System</div>
                    <span class="status-value" id="audioSystemStatus">Ready</span>
                </div>
                <div class="status-card">
                    <div>Characters Detected</div>
                    <span class="status-value" id="charactersDetected">0</span>
                </div>
                <div class="status-card">
                    <div>System FPS</div>
                    <span class="status-value" id="systemFPS">0</span>
                </div>
                <div class="status-card">
                    <div>Behavior Queue</div>
                    <span class="status-value" id="behaviorQueueStatus">0 pending</span>
                </div>
                <div class="status-card">
                    <div>Response Time</div>
                    <span class="status-value" id="responseTime">< 100ms</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Security Utilities Library -->
    <script src="dashboard-security-utils.js"></script>
    <script>
        // Global auth token variable (will be set by initializeAuth)
        let AUTH_TOKEN = null;

        // Initialize authentication by fetching token from API
        async function initializeAuthToken() {
            try {
                // Fetch current token from WCB API
                const response = await fetch('http://localhost:8770/api/auth/token');
                const data = await response.json();

                AUTH_TOKEN = data.token;

                // Store in localStorage for session persistence
                localStorage.setItem('r2d2_auth_token', AUTH_TOKEN);

                console.log('‚úÖ Auth token retrieved from server:', AUTH_TOKEN.substring(0, 8) + '...');
                console.log('‚úÖ Token type:', data.type);
                console.log('‚úÖ Token status:', data.status);

                // Initialize auth manager with retrieved token (if available from security utils)
                if (typeof initializeAuth !== 'undefined') {
                    window.initializeAuth(AUTH_TOKEN);
                }

                return AUTH_TOKEN;
            } catch (error) {
                console.error('‚ùå Failed to retrieve auth token from server:', error);

                // Fallback to localStorage
                const storedToken = localStorage.getItem('r2d2_auth_token');
                if (storedToken) {
                    AUTH_TOKEN = storedToken;
                    console.warn('‚ö†Ô∏è Using stored token from localStorage:', AUTH_TOKEN.substring(0, 8) + '...');
                    return AUTH_TOKEN;
                }

                // Ultimate fallback for development
                console.error('‚ö†Ô∏è No token available - API calls will fail');
                console.error('‚ö†Ô∏è Please ensure WCB API is running on http://localhost:8770');
                return null;
            }
        }

        // Authentication required handler
        function handleAuthenticationRequired() {
            console.error('Authentication required');
            if (typeof toastManager !== 'undefined') {
                toastManager.show('Authentication required - please refresh page', 'warning', 5000);
            }
            // Retry auth initialization
            initializeAuthToken();
        }

        // Network error handler
        function handleNetworkError(error) {
            console.error('Network error:', error);
            if (typeof toastManager !== 'undefined') {
                toastManager.show('Network error: ' + error.message, 'error', 5000);
            }
        }

        // Initialize auth on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeAuthToken();
            console.log('‚úÖ Enhanced Dashboard authentication initialized');
        });
    </script>

    <script>
        // HIGHEST QUALITY WebSocket Connection Management System
        let visionWs = null;
        let dashboardWs = null;
        let behaviorWs = null;

        // Advanced Connection Recovery System
        let connectionManager = {
            vision: { ws: null, reconnectInterval: null, reconnectAttempts: 0, maxAttempts: 10, status: 'disconnected' },
            dashboard: { ws: null, reconnectInterval: null, reconnectAttempts: 0, maxAttempts: 10, status: 'disconnected' },
            behavior: { ws: null, reconnectInterval: null, reconnectAttempts: 0, maxAttempts: 10, status: 'disconnected' }
        };

        // Connection Quality Monitoring
        let connectionHealth = {
            vision: { latency: 0, lastHeartbeat: 0, messagesReceived: 0, errors: 0 },
            dashboard: { latency: 0, lastHeartbeat: 0, messagesReceived: 0, errors: 0 },
            behavior: { latency: 0, lastHeartbeat: 0, messagesReceived: 0, errors: 0 }
        };

        // Application State
        let currentCharacter = null;
        let currentPersonality = 'curious';
        let controlMode = 'auto';
        let behaviorQueue = [];
        let queuePaused = false;
        let environmentData = {
            motionLevel: 'low',
            noiseLevel: 'quiet',
            peopleCount: 0
        };
        let behaviorStatus = {
            current: 'Idle - Curious',
            progress: 0,
            duration: '00:00',
            totalDuration: '00:00'
        };

        // Performance Monitoring
        let performanceMetrics = {
            frameCount: 0,
            lastFrameTime: 0,
            averageFPS: 0,
            messageQueue: [],
            renderTime: 0
        };

        // HIGHEST QUALITY Initialization System
        function initialize() {
            console.log('üöÄ Initializing R2D2 Enhanced Dashboard with Quality Systems');

            // Initialize connection quality monitoring
            initializeConnectionHealthMonitoring();

            // Initialize performance monitoring
            initializePerformanceMonitoring();

            // Initialize security measures
            initializeSecurityProtection();

            // Connect to all systems with advanced error handling
            connectToAllSystems();

            // Initialize UI state
            updateBehaviorStatusDisplay();
            updateEnvironmentDisplay();

            // Start health monitoring intervals
            startSystemMonitoring();

            console.log('‚úÖ Dashboard initialization complete with quality controls');
        }

        // PROFESSIONAL-GRADE Vision System Connection with Full Error Handling
        function connectToVisionSystem() {
            const connection = connectionManager.vision;
            connection.status = 'connecting';

            try {
                console.log('üé• Connecting to Vision System (Attempt ' + (connection.reconnectAttempts + 1) + ')');

                // SECURITY FIX: Add authentication token to WebSocket URL
                const wsUrlWithAuth = `ws://localhost:8767?token=${AUTH_TOKEN}`;
                connection.ws = new WebSocket(wsUrlWithAuth);
                visionWs = connection.ws; // Maintain backward compatibility

                // Enhanced connection timeout
                const connectionTimeout = setTimeout(() => {
                    if (connection.ws.readyState === WebSocket.CONNECTING) {
                        console.warn('‚è∞ Vision connection timeout');
                        connection.ws.close();
                        handleVisionConnectionFailure('Connection timeout');
                    }
                }, 10000);

                connection.ws.onopen = function() {
                    clearTimeout(connectionTimeout);
                    connection.status = 'connected';
                    connection.reconnectAttempts = 0;
                    connectionHealth.vision.lastHeartbeat = Date.now();

                    console.log('‚úÖ Vision System Connected Successfully');
                    document.getElementById('visionStatus').textContent = 'Connected';
                    updateConnectionStatus(true);

                    // Clear any reconnection intervals
                    if (connection.reconnectInterval) {
                        clearInterval(connection.reconnectInterval);
                        connection.reconnectInterval = null;
                    }

                    // Request initial status
                    sendVisionCommand('request_status', {});
                };

                connection.ws.onmessage = function(event) {
                    const messageStart = performance.now();

                    try {
                        connectionHealth.vision.messagesReceived++;
                        connectionHealth.vision.lastHeartbeat = Date.now();

                        const data = JSON.parse(event.data);
                        handleVisionData(data);

                        // Update performance metrics
                        const processingTime = performance.now() - messageStart;
                        updatePerformanceMetrics('vision_message', processingTime);

                    } catch (error) {
                        console.error('‚ùå Vision message processing error:', error);
                        connectionHealth.vision.errors++;
                    }
                };

                connection.ws.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    connection.status = 'disconnected';

                    console.log('‚ö†Ô∏è Vision System Disconnected:', event.code, event.reason);
                    document.getElementById('visionStatus').textContent = 'Disconnected';
                    updateConnectionStatus(false);
                    hideVideoFeed();

                    // Only attempt reconnection if not a clean close
                    if (event.code !== 1000) {
                        handleVisionConnectionFailure('Connection closed: ' + event.reason);
                    }
                };

                connection.ws.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå Vision WebSocket Error:', error);
                    connectionHealth.vision.errors++;
                    handleVisionConnectionFailure('WebSocket error: ' + error.message);
                };

            } catch (error) {
                console.error('‚ùå Vision Connection Creation Failed:', error);
                handleVisionConnectionFailure('Failed to create connection: ' + error.message);
            }
        }

        // PROFESSIONAL-GRADE Dashboard Connection with Full Error Handling
        function connectToDashboard() {
            const connection = connectionManager.dashboard;
            connection.status = 'connecting';

            try {
                console.log('üéõÔ∏è Connecting to Dashboard System (Attempt ' + (connection.reconnectAttempts + 1) + ')');

                // SECURITY FIX: Add authentication token to WebSocket URL
                const wsUrlWithAuth = `ws://localhost:8766?token=${AUTH_TOKEN}`;
                connection.ws = new WebSocket(wsUrlWithAuth);
                dashboardWs = connection.ws;

                const connectionTimeout = setTimeout(() => {
                    if (connection.ws.readyState === WebSocket.CONNECTING) {
                        console.warn('‚è∞ Dashboard connection timeout');
                        connection.ws.close();
                        handleDashboardConnectionFailure('Connection timeout');
                    }
                }, 8000);

                connection.ws.onopen = function() {
                    clearTimeout(connectionTimeout);
                    connection.status = 'connected';
                    connection.reconnectAttempts = 0;
                    connectionHealth.dashboard.lastHeartbeat = Date.now();

                    console.log('‚úÖ Dashboard System Connected Successfully');

                    if (connection.reconnectInterval) {
                        clearInterval(connection.reconnectInterval);
                        connection.reconnectInterval = null;
                    }

                    // Request initial system status
                    sendDashboardCommand('request_status', {});
                };

                connection.ws.onmessage = function(event) {
                    const messageStart = performance.now();

                    try {
                        connectionHealth.dashboard.messagesReceived++;
                        connectionHealth.dashboard.lastHeartbeat = Date.now();

                        const data = JSON.parse(event.data);
                        handleDashboardData(data);

                        const processingTime = performance.now() - messageStart;
                        updatePerformanceMetrics('dashboard_message', processingTime);

                    } catch (error) {
                        console.error('‚ùå Dashboard message processing error:', error);
                        connectionHealth.dashboard.errors++;
                    }
                };

                connection.ws.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    connection.status = 'disconnected';

                    console.log('‚ö†Ô∏è Dashboard System Disconnected:', event.code, event.reason);

                    if (event.code !== 1000) {
                        handleDashboardConnectionFailure('Connection closed: ' + event.reason);
                    }
                };

                connection.ws.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå Dashboard WebSocket Error:', error);
                    connectionHealth.dashboard.errors++;
                    handleDashboardConnectionFailure('WebSocket error: ' + error.message);
                };

            } catch (error) {
                console.error('‚ùå Dashboard Connection Creation Failed:', error);
                handleDashboardConnectionFailure('Failed to create connection: ' + error.message);
            }
        }

        // Flicker-free frame management with improved error handling
        let lastFrameTime = 0;
        let frameThrottleInterval = 1000 / 15; // Max 15 FPS display
        let pendingFrameUpdate = false;
        let frameUpdateCount = 0;

        function updateVideoFeedWithFlickerFree(frameData) {
            if (!frameData) {
                console.warn('‚ö†Ô∏è updateVideoFeedWithFlickerFree called with no frame data');
                return;
            }

            const currentTime = Date.now();
            const timeSinceLastFrame = currentTime - lastFrameTime;

            // Only throttle if we recently had a successful frame AND pending is true
            // Force update if it's been more than 5 seconds since last frame
            if (pendingFrameUpdate && timeSinceLastFrame < 5000) {
                console.log(`‚è≠Ô∏è Frame throttled (${timeSinceLastFrame}ms since last, pending=${pendingFrameUpdate})`);
                return;
            }

            // Update video feed with flicker-free rendering
            const videoFeed = document.getElementById('videoFeed');
            const noVideo = document.getElementById('noVideo');

            if (!videoFeed || !noVideo) {
                console.error('‚ùå Video elements not found in DOM');
                return;
            }

            pendingFrameUpdate = true;

            // Create new image for smooth transition
            const newImg = new Image();

            newImg.onload = function() {
                // Only update if image loaded successfully
                requestAnimationFrame(() => {
                    videoFeed.src = this.src;
                    videoFeed.style.display = 'block';
                    noVideo.style.display = 'none';

                    lastFrameTime = currentTime;
                    pendingFrameUpdate = false;
                    frameUpdateCount++;

                    console.log(`‚úÖ Frame #${frameUpdateCount} rendered (${this.naturalWidth}x${this.naturalHeight}) after ${timeSinceLastFrame}ms`);
                });
            };

            newImg.onerror = function() {
                pendingFrameUpdate = false;
                console.error('‚ùå Failed to load video frame - invalid base64 data');
                console.error('Frame data length:', frameData.length);
                console.error('First 100 chars:', frameData.substring(0, 100));
            };

            // Set timeout to prevent stuck pending state
            setTimeout(() => {
                if (pendingFrameUpdate) {
                    console.warn('‚ö†Ô∏è Frame load timeout - resetting pending state');
                    pendingFrameUpdate = false;
                }
            }, 2000);

            newImg.src = 'data:image/jpeg;base64,' + frameData;
        }

        function hideVideoFeed() {
            document.getElementById('videoFeed').style.display = 'none';
            const noVideo = document.getElementById('noVideo');
            noVideo.style.display = 'flex';

            // XSS FIX: Use textContent for static content (consistency with WCB dashboard)
            noVideo.textContent = 'üì∑ Vision system disconnected - Attempting to reconnect...';
        }

        function handleVisionData(data) {
            console.log('handleVisionData() called with type:', data.type);

            // Handle ALL vision message types: vision_data, video_frame, character_vision_data
            if (data.type === 'video_frame' || data.type === 'vision_data') {
                console.log(`Processing ${data.type} - hasFrame: ${!!data.frame}`);
                // Update vision frame with flicker-free webcam feed
                if (data.frame) {
                    console.log(`Calling updateVideoFeedWithFlickerFree() with frame length: ${data.frame.length}`);
                    updateVideoFeedWithFlickerFree(data.frame);
                } else {
                    console.warn(`‚ö†Ô∏è ${data.type} message has no frame data!`);
                }

                // Update frame stats
                if (data.frame_number) {
                    document.getElementById('charactersDetected').textContent = data.frame_number;
                }

                // Update detections if present
                if (data.detections && Array.isArray(data.detections)) {
                    document.getElementById('charactersDetected').textContent = data.detections.length;
                }

                // Update stats if present
                if (data.stats) {
                    if (data.stats.fps !== undefined) {
                        document.getElementById('systemFPS').textContent = data.stats.fps.toFixed(1);
                    }
                }
            } else if (data.type === 'status') {
                // Update system status
                if (data.frame_count) {
                    document.getElementById('systemFPS').textContent = (data.frame_count / data.uptime).toFixed(1);
                }
            } else if (data.type === 'character_vision_data') {
                console.log('Processing character_vision_data - hasFrame:', !!data.frame);
                // Handle character detection with flicker-free video feed
                if (data.frame) {
                    console.log(`Calling updateVideoFeedWithFlickerFree() with frame length: ${data.frame.length}`);
                    updateVideoFeedWithFlickerFree(data.frame);
                } else {
                    console.warn('‚ö†Ô∏è character_vision_data message has no frame data!');
                }

                // Update character detection
                if (data.character_detections && data.character_detections.length > 0) {
                    const character = data.character_detections[0];
                    showCharacterDetection(character);
                    currentCharacter = character;
                } else {
                    hideCharacterDetection();
                    currentCharacter = null;
                }

                // Update stats with proper error handling
                if (data.stats) {
                    document.getElementById('systemFPS').textContent = data.stats.fps.toFixed(1);
                    document.getElementById('charactersDetected').textContent = data.character_detections ? data.character_detections.length : 0;
                }
            } else {
                console.warn(`‚ö†Ô∏è handleVisionData() received unknown type: ${data.type}`);
            }
        }

        function handleDashboardData(data) {
            // Handle dashboard-specific data
            console.log('Dashboard data received:', {
                type: data.type,
                hasFrame: !!data.frame,
                frameLength: data.frame ? data.frame.length : 0,
                hasStats: !!data.stats,
                allKeys: Object.keys(data)
            });

            // Route vision messages to vision handler
            if (data.type === 'character_vision_data' || data.type === 'vision_data' || data.type === 'video_frame') {
                console.log(`‚úÖ Routing ${data.type} to handleVisionData()`);
                handleVisionData(data);
            } else {
                console.warn(`‚ö†Ô∏è Unknown message type: ${data.type}`);
            }
        }

        function showCharacterDetection(character) {
            const detection = document.getElementById('characterDetection');
            const name = document.getElementById('characterName');
            const confidence = document.getElementById('characterConfidence');
            const reaction = document.getElementById('characterReaction');

            name.textContent = character.name;
            confidence.textContent = `Confidence: ${(character.confidence * 100).toFixed(1)}%`;
            reaction.textContent = `R2D2 Reaction: ${character.r2d2_reaction.primary_emotion}`;

            detection.classList.add('active');
        }

        function hideCharacterDetection() {
            document.getElementById('characterDetection').classList.remove('active');
        }

        // ENHANCED Connection Status Management
        function updateConnectionStatus(connected) {
            // This function is maintained for backward compatibility
            // The new system uses updateConnectionStatusIndicators() for more sophisticated status management
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'Connected';
                status.classList.add('connected');
            } else {
                status.textContent = 'Disconnected';
                status.classList.remove('connected');
            }
        }

        // ADVANCED Connection Recovery and Health Management Functions
        function handleVisionConnectionFailure(reason) {
            const connection = connectionManager.vision;

            if (connection.reconnectAttempts >= connection.maxAttempts) {
                console.error('üí• Vision System: Maximum reconnection attempts reached');
                showSystemAlert('Vision system unavailable after multiple attempts', 'critical');
                return;
            }

            connection.reconnectAttempts++;
            console.log(`üîÑ Vision System Reconnection ${connection.reconnectAttempts}/${connection.maxAttempts}: ${reason}`);

            if (!connection.reconnectInterval) {
                const backoffDelay = Math.min(5000 * Math.pow(2, connection.reconnectAttempts - 1), 30000);

                connection.reconnectInterval = setTimeout(() => {
                    connection.reconnectInterval = null;
                    connectToVisionSystem();
                }, backoffDelay);
            }
        }

        function handleDashboardConnectionFailure(reason) {
            const connection = connectionManager.dashboard;

            if (connection.reconnectAttempts >= connection.maxAttempts) {
                console.error('üí• Dashboard System: Maximum reconnection attempts reached');
                showSystemAlert('Dashboard system unavailable after multiple attempts', 'critical');
                return;
            }

            connection.reconnectAttempts++;
            console.log(`üîÑ Dashboard System Reconnection ${connection.reconnectAttempts}/${connection.maxAttempts}: ${reason}`);

            if (!connection.reconnectInterval) {
                const backoffDelay = Math.min(3000 * Math.pow(2, connection.reconnectAttempts - 1), 20000);

                connection.reconnectInterval = setTimeout(() => {
                    connection.reconnectInterval = null;
                    connectToDashboard();
                }, backoffDelay);
            }
        }

        function handleBehaviorConnectionFailure(reason) {
            const connection = connectionManager.behavior;

            if (connection.reconnectAttempts >= connection.maxAttempts) {
                console.error('üí• Behavior System: Maximum reconnection attempts reached');
                showSystemAlert('Behavioral intelligence system unavailable after multiple attempts', 'critical');
                return;
            }

            connection.reconnectAttempts++;
            console.log(`üîÑ Behavior System Reconnection ${connection.reconnectAttempts}/${connection.maxAttempts}: ${reason}`);

            if (!connection.reconnectInterval) {
                const backoffDelay = Math.min(4000 * Math.pow(2, connection.reconnectAttempts - 1), 25000);

                connection.reconnectInterval = setTimeout(() => {
                    connection.reconnectInterval = null;
                    connectToBehaviorSystem();
                }, backoffDelay);
            }
        }

        // Servo control functions
        function updateServo(channel, value) {
            const valueElement = document.getElementById(getServoValueId(channel));
            if (valueElement) {
                valueElement.textContent = value + '¬µs';
            }

            // Send servo command
            sendServoCommand(channel, parseInt(value));
        }

        function getServoValueId(channel) {
            const ids = {
                0: 'domeRotationValue',
                1: 'headTiltValue',
                2: 'periscopeValue',
                4: 'leftArmValue',
                5: 'rightArmValue',
                6: 'frontPanelValue',
                7: 'leftPanelValue',
                8: 'rightPanelValue'
            };
            return ids[channel];
        }

        // ENHANCED Servo Command with Input Validation and Error Handling
        function sendServoCommand(channel, position) {
            // Input validation for security and reliability
            if (!validateServoInput(channel, position)) {
                console.error('‚ùå Invalid servo command parameters');
                showSystemAlert('Invalid servo command rejected', 'warning');
                return false;
            }

            const command = {
                type: 'servo_command',
                channel: parseInt(channel),
                position: parseInt(position),
                timestamp: Date.now(),
                source: 'enhanced_dashboard'
            };

            if (dashboardWs && dashboardWs.readyState === WebSocket.OPEN) {
                try {
                    dashboardWs.send(JSON.stringify(command));
                    console.log(`‚úÖ Servo Command Sent: Channel ${channel} -> ${position}¬µs`);
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to send servo command:', error);
                    showSystemAlert('Failed to send servo command', 'error');
                    return false;
                }
            } else {
                console.warn('‚ö†Ô∏è Dashboard not connected, servo command queued');
                showSystemAlert('Dashboard offline - command queued', 'warning');
                return false;
            }
        }

        // Input validation for servo commands
        function validateServoInput(channel, position) {
            // Channel validation
            if (!Number.isInteger(Number(channel)) || channel < 0 || channel > 31) {
                console.error('Invalid servo channel:', channel);
                return false;
            }

            // Position validation (typical servo range)
            if (!Number.isInteger(Number(position)) || position < 500 || position > 2500) {
                console.error('Invalid servo position:', position);
                return false;
            }

            return true;
        }

        function homeAllServos() {
            console.log('Homing all servos...');
            const homePositions = {
                0: 1500, 1: 1500, 2: 1000, 4: 1000, 5: 1000,
                6: 1000, 7: 1000, 8: 1000
            };

            for (const [channel, position] of Object.entries(homePositions)) {
                sendServoCommand(parseInt(channel), position);
                const slider = document.querySelector(`input[oninput*="updateServo(${channel}"`);
                if (slider) {
                    slider.value = position;
                    updateServo(parseInt(channel), position);
                }
            }
        }

        function testServos() {
            console.log('Testing servos...');
            // Implement servo test sequence
        }

        function servoEmergencyStop() {
            console.log('Servo emergency stop!');
            const command = {
                type: 'emergency_stop',
                system: 'servos',
                timestamp: Date.now()
            };

            if (dashboardWs && dashboardWs.readyState === WebSocket.OPEN) {
                dashboardWs.send(JSON.stringify(command));
            }
        }

        // Audio functions
        function playSound(soundName) {
            console.log(`Playing sound: ${soundName}`);
            const command = {
                type: 'audio_command',
                sound: soundName,
                timestamp: Date.now()
            };

            if (dashboardWs && dashboardWs.readyState === WebSocket.OPEN) {
                dashboardWs.send(JSON.stringify(command));
            }
        }

        function playCharacterGreeting() {
            if (currentCharacter) {
                console.log(`Playing greeting for ${currentCharacter.name}`);
                playSound(`greeting_${currentCharacter.name.toLowerCase().replace(' ', '_')}`);
            } else {
                playSound('beep_happy');
            }
        }

        function playRandomSound() {
            const sounds = ['beep_happy', 'beep_excited', 'whistle', 'chirp'];
            const randomSound = sounds[Math.floor(Math.random() * sounds.length)];
            playSound(randomSound);
        }

        function stopAllAudio() {
            console.log('Stopping all audio');
            const command = {
                type: 'audio_stop_all',
                timestamp: Date.now()
            };

            if (dashboardWs && dashboardWs.readyState === WebSocket.OPEN) {
                dashboardWs.send(JSON.stringify(command));
            }
        }

        // Behavior pattern functions
        function executePattern(patternName) {
            console.log(`Executing pattern: ${patternName}`);
            const command = {
                type: 'behavior_pattern',
                pattern: patternName,
                timestamp: Date.now()
            };

            if (dashboardWs && dashboardWs.readyState === WebSocket.OPEN) {
                dashboardWs.send(JSON.stringify(command));
            }
        }

        // PROFESSIONAL-GRADE Emergency Stop with Full System Shutdown
        function emergencyStop() {
            console.log('üö® EMERGENCY STOP ACTIVATED - SHUTTING DOWN ALL SYSTEMS');

            const emergencyCommand = {
                type: 'emergency_stop',
                system: 'all',
                timestamp: Date.now(),
                priority: 'CRITICAL',
                source: 'enhanced_dashboard'
            };

            // Send emergency stop to all connected systems
            let commandsSent = 0;

            Object.keys(connectionManager).forEach(system => {
                const connection = connectionManager[system];
                if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                    try {
                        connection.ws.send(JSON.stringify(emergencyCommand));
                        commandsSent++;
                        console.log(`‚úÖ Emergency stop sent to ${system} system`);
                    } catch (error) {
                        console.error(`‚ùå Failed to send emergency stop to ${system}:`, error);
                    }
                }
            });

            console.log(`üö® Emergency stop commands sent to ${commandsSent} systems`);

            // Clear all behavior queues
            behaviorQueue = [];
            queuePaused = true;
            updateQueueDisplay();

            // Update UI to show emergency state
            showEmergencyState();

            // Log emergency stop for audit trail
            logEmergencyStop();

            showSystemAlert('EMERGENCY STOP ACTIVATED - All systems halted', 'critical');
        }

        function showEmergencyState() {
            // Visual feedback with professional emergency styling
            document.body.style.background = 'linear-gradient(135deg, #991b1b 0%, #dc2626 100%)';

            // Update all status indicators to emergency state
            document.getElementById('visionStatus').textContent = 'EMERGENCY STOP';
            document.getElementById('behaviorStatus').textContent = 'EMERGENCY STOP';
            document.getElementById('servoStatus').textContent = 'EMERGENCY STOP';
            document.getElementById('audioSystemStatus').textContent = 'EMERGENCY STOP';

            // Flash emergency stop button
            const emergencyBtn = document.querySelector('.emergency-stop button');
            if (emergencyBtn) {
                emergencyBtn.style.animation = 'pulse 0.3s infinite';
                emergencyBtn.textContent = 'üö® SYSTEMS STOPPED';
            }

            // Disable all control buttons
            document.querySelectorAll('.control-button, .audio-button, .personality-button, .response-button').forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
            });

            // Show emergency recovery options after 3 seconds
            setTimeout(showEmergencyRecoveryOptions, 3000);

            // Restore normal background after 10 seconds but keep emergency indicators
            setTimeout(() => {
                document.body.style.background = 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)';
            }, 10000);
        }

        function showEmergencyRecoveryOptions() {
            const emergencyBtn = document.querySelector('.emergency-stop button');
            if (emergencyBtn) {
                emergencyBtn.textContent = 'üîÑ RESTART SYSTEMS';
                emergencyBtn.onclick = restartAllSystems;
                emergencyBtn.style.animation = 'pulse 2s infinite';
            }
        }

        function restartAllSystems() {
            console.log('üîÑ Restarting all R2D2 systems after emergency stop');

            // Re-enable all controls
            document.querySelectorAll('.control-button, .audio-button, .personality-button, .response-button').forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
            });

            // Reset emergency stop button
            const emergencyBtn = document.querySelector('.emergency-stop button');
            if (emergencyBtn) {
                emergencyBtn.textContent = 'üö® EMERGENCY STOP';
                emergencyBtn.onclick = emergencyStop;
                emergencyBtn.style.animation = 'pulse 2s infinite';
            }

            // Reset behavior queue state
            queuePaused = false;

            // Reconnect to all systems
            setTimeout(() => {
                console.log('üîå Reconnecting to all systems');
                connectToAllSystems();
            }, 1000);

            showSystemAlert('Systems restart initiated', 'info');
        }

        function logEmergencyStop() {
            const logEntry = {
                timestamp: new Date().toISOString(),
                event: 'EMERGENCY_STOP',
                source: 'enhanced_dashboard',
                systems_connected: Object.keys(connectionManager).filter(system =>
                    connectionManager[system].status === 'connected'
                ).length,
                user_agent: navigator.userAgent,
                page_url: window.location.href
            };

            console.log('üìã Emergency Stop Log Entry:', logEntry);

            // In a production environment, this would be sent to a logging service
            // For now, we store it in localStorage for debugging
            try {
                const existingLogs = JSON.parse(localStorage.getItem('r2d2_emergency_logs') || '[]');
                existingLogs.push(logEntry);
                localStorage.setItem('r2d2_emergency_logs', JSON.stringify(existingLogs.slice(-50))); // Keep only last 50 logs
            } catch (error) {
                console.warn('Failed to store emergency log:', error);
            }
        }

        // ===== BEHAVIORAL INTELLIGENCE FUNCTIONS =====

        // PROFESSIONAL-GRADE Behavioral Intelligence Connection with Full Error Handling
        function connectToBehaviorSystem() {
            const connection = connectionManager.behavior;
            connection.status = 'connecting';

            try {
                console.log('üß† Connecting to Behavioral Intelligence System (Attempt ' + (connection.reconnectAttempts + 1) + ')');

                // SECURITY FIX: Add authentication token to WebSocket URL
                const wsUrlWithAuth = `ws://localhost:8768?token=${AUTH_TOKEN}`;
                connection.ws = new WebSocket(wsUrlWithAuth);
                behaviorWs = connection.ws;

                const connectionTimeout = setTimeout(() => {
                    if (connection.ws.readyState === WebSocket.CONNECTING) {
                        console.warn('‚è∞ Behavioral system connection timeout');
                        connection.ws.close();
                        handleBehaviorConnectionFailure('Connection timeout');
                    }
                }, 12000);

                connection.ws.onopen = function() {
                    clearTimeout(connectionTimeout);
                    connection.status = 'connected';
                    connection.reconnectAttempts = 0;
                    connectionHealth.behavior.lastHeartbeat = Date.now();

                    console.log('‚úÖ Behavioral Intelligence System Connected Successfully');
                    document.getElementById('behaviorStatus').textContent = 'Connected';

                    if (connection.reconnectInterval) {
                        clearInterval(connection.reconnectInterval);
                        connection.reconnectInterval = null;
                    }

                    // Initialize behavioral system with current state
                    sendBehaviorCommand('initialize', {
                        personality: currentPersonality,
                        mode: controlMode,
                        timestamp: Date.now()
                    });
                };

                connection.ws.onmessage = function(event) {
                    const messageStart = performance.now();

                    try {
                        connectionHealth.behavior.messagesReceived++;
                        connectionHealth.behavior.lastHeartbeat = Date.now();

                        const data = JSON.parse(event.data);
                        handleBehaviorData(data);

                        const processingTime = performance.now() - messageStart;
                        updatePerformanceMetrics('behavior_message', processingTime);

                    } catch (error) {
                        console.error('‚ùå Behavioral message processing error:', error);
                        connectionHealth.behavior.errors++;
                    }
                };

                connection.ws.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    connection.status = 'disconnected';

                    console.log('‚ö†Ô∏è Behavioral Intelligence System Disconnected:', event.code, event.reason);
                    document.getElementById('behaviorStatus').textContent = 'Disconnected';

                    if (event.code !== 1000) {
                        handleBehaviorConnectionFailure('Connection closed: ' + event.reason);
                    }
                };

                connection.ws.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå Behavioral WebSocket Error:', error);
                    connectionHealth.behavior.errors++;
                    document.getElementById('behaviorStatus').textContent = 'Error';
                    handleBehaviorConnectionFailure('WebSocket error: ' + error.message);
                };

            } catch (error) {
                console.error('‚ùå Behavioral Connection Creation Failed:', error);
                document.getElementById('behaviorStatus').textContent = 'Error';
                handleBehaviorConnectionFailure('Failed to create connection: ' + error.message);
            }
        }

        function handleBehaviorData(data) {
            switch(data.type) {
                case 'behavior_status_update':
                    updateBehaviorStatus(data.status);
                    break;
                case 'environment_update':
                    updateEnvironmentData(data.environment);
                    break;
                case 'queue_update':
                    updateQueueDisplay(data.queue);
                    break;
                case 'servo_activity_update':
                    updateServoActivityDisplay(data.servos);
                    break;
                case 'audio_status_update':
                    updateAudioStatusDisplay(data.audio);
                    break;
                case 'character_update':
                    updateCharacterRecognition(data.characters);
                    break;
            }
        }

        // Personality Mode Control
        function setPersonalityMode(mode) {
            currentPersonality = mode;

            // Update UI
            document.querySelectorAll('.personality-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });

            // Send to behavioral system
            sendBehaviorCommand('personality_change', { mode: mode });

            console.log(`Personality mode changed to: ${mode}`);
            updateBehaviorStatusDisplay();
        }

        // Control Mode Toggle
        function setControlMode(mode) {
            controlMode = mode;

            // Update UI
            document.getElementById('autoMode').classList.remove('active');
            document.getElementById('manualMode').classList.remove('active');
            document.getElementById(mode + 'Mode').classList.add('active');

            // Send to behavioral system
            sendBehaviorCommand('control_mode_change', { mode: mode });

            console.log(`Control mode changed to: ${mode}`);
        }

        // Environmental Sensitivity Controls
        function updateSensitivity(type, value) {
            const valueElement = document.getElementById(type + 'Value');
            if (valueElement) {
                valueElement.textContent = value + '%';
            }

            // Send sensitivity update
            sendBehaviorCommand('sensitivity_update', {
                type: type,
                value: parseInt(value)
            });

            console.log(`${type} sensitivity updated to ${value}%`);
        }

        // Quick Response Triggers
        function triggerQuickResponse(responseType) {
            const responses = {
                curious: {
                    name: 'Curious Investigation',
                    duration: 3000,
                    actions: ['head_tilt', 'investigating_beeps', 'slow_dome_turn']
                },
                excited: {
                    name: 'Excited Celebration',
                    duration: 5000,
                    actions: ['dome_spin', 'happy_chirps', 'panel_flutter']
                },
                worried: {
                    name: 'Worried Response',
                    duration: 4000,
                    actions: ['head_shake', 'concerned_beeps', 'defensive_posture']
                },
                playful: {
                    name: 'Playful Interaction',
                    duration: 6000,
                    actions: ['panels_open', 'playful_sounds', 'head_nods']
                },
                greeting: {
                    name: 'Friendly Greeting',
                    duration: 3000,
                    actions: ['greeting_nod', 'friendly_whistle', 'dome_wiggle']
                },
                alert: {
                    name: 'Alert State',
                    duration: 2000,
                    actions: ['rapid_dome_turn', 'alert_tone', 'periscope_extend']
                },
                celebration: {
                    name: 'Victory Celebration',
                    duration: 8000,
                    actions: ['all_panels_open', 'victory_beeps', 'full_dome_spin']
                },
                sleepy: {
                    name: 'Sleepy Mode',
                    duration: 5000,
                    actions: ['slow_movements', 'yawn_sounds', 'dome_droop']
                }
            };

            const response = responses[responseType];
            if (response) {
                // Add to behavior queue if not in manual mode
                if (controlMode === 'auto') {
                    addToBehaviorQueue(response);
                } else {
                    // Execute immediately in manual mode
                    executeBehaviorResponse(response);
                }
            }
        }

        // Behavior Queue Management
        function addToBehaviorQueue(behavior) {
            behaviorQueue.push({
                id: Date.now(),
                name: behavior.name,
                duration: behavior.duration,
                actions: behavior.actions,
                timestamp: new Date().toLocaleTimeString()
            });

            updateQueueDisplay();

            // Auto-execute if queue was empty and not paused
            if (behaviorQueue.length === 1 && !queuePaused) {
                processNextBehavior();
            }
        }

        function processNextBehavior() {
            if (behaviorQueue.length > 0 && !queuePaused) {
                const behavior = behaviorQueue.shift();
                executeBehaviorResponse(behavior);
                updateQueueDisplay();

                // Schedule next behavior
                setTimeout(() => {
                    processNextBehavior();
                }, behavior.duration + 500);
            }
        }

        function executeBehaviorResponse(behavior) {
            console.log(`Executing behavior: ${behavior.name}`);

            // Update current behavior display
            behaviorStatus.current = behavior.name;
            behaviorStatus.progress = 0;
            behaviorStatus.duration = '00:00';
            behaviorStatus.totalDuration = formatDuration(behavior.duration);

            updateBehaviorStatusDisplay();

            // Send behavior command
            sendBehaviorCommand('execute_behavior', {
                name: behavior.name,
                actions: behavior.actions,
                duration: behavior.duration
            });

            // Simulate progress
            simulateBehaviorProgress(behavior.duration);
        }

        function simulateBehaviorProgress(duration) {
            const startTime = Date.now();
            const updateInterval = 100;

            // MEMORY LEAK FIX: Use ManagedInterval for automatic cleanup
            const progressInterval = new ManagedInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);

                behaviorStatus.progress = progress;
                behaviorStatus.duration = formatDuration(elapsed);

                updateBehaviorStatusDisplay();

                if (progress >= 100) {
                    progressInterval.stop();

                    // MEMORY LEAK FIX: Use ManagedTimeout for automatic cleanup
                    const idleTimeout = new ManagedTimeout(() => {
                        behaviorStatus.current = `Idle - ${currentPersonality}`;
                        behaviorStatus.progress = 0;
                        behaviorStatus.duration = '00:00';
                        updateBehaviorStatusDisplay();
                    }, 500, 'behaviorIdleReturn');
                    idleTimeout.start();
                    resourceManager.registerTimeout('behaviorIdleReturn', idleTimeout);
                }
            }, updateInterval, 'behaviorProgress');

            progressInterval.start();
            resourceManager.registerInterval('behaviorProgress', progressInterval);
        }

        function pauseQueue() {
            queuePaused = true;
            sendBehaviorCommand('queue_pause', {});
            console.log('Behavior queue paused');
        }

        function resumeQueue() {
            queuePaused = false;
            sendBehaviorCommand('queue_resume', {});
            processNextBehavior();
            console.log('Behavior queue resumed');
        }

        function clearQueue() {
            behaviorQueue = [];
            queuePaused = false;
            updateQueueDisplay();
            sendBehaviorCommand('queue_clear', {});
            console.log('Behavior queue cleared');
        }

        // Demo Sequence Controls
        function startDemo(demoType) {
            const demos = {
                convention: {
                    name: 'Convention Demo',
                    behaviors: [
                        { name: 'Welcome Greeting', duration: 5000 },
                        { name: 'Character Recognition Demo', duration: 10000 },
                        { name: 'Servo Showcase', duration: 8000 },
                        { name: 'Audio Performance', duration: 7000 },
                        { name: 'Interactive Mode', duration: 15000 }
                    ]
                },
                patrol: {
                    name: 'Security Patrol',
                    behaviors: [
                        { name: 'Area Scan', duration: 6000 },
                        { name: 'Perimeter Check', duration: 8000 },
                        { name: 'Motion Detection', duration: 5000 },
                        { name: 'Status Report', duration: 3000 }
                    ]
                },
                interactive: {
                    name: 'Interactive Mode',
                    behaviors: [
                        { name: 'People Detection', duration: 4000 },
                        { name: 'Greeting Protocol', duration: 3000 },
                        { name: 'Response Mode', duration: 12000 }
                    ]
                },
                maintenance: {
                    name: 'Self-Check Routine',
                    behaviors: [
                        { name: 'Servo Calibration', duration: 8000 },
                        { name: 'Audio Test', duration: 5000 },
                        { name: 'Vision System Check', duration: 6000 },
                        { name: 'Status Report', duration: 3000 }
                    ]
                }
            };

            const demo = demos[demoType];
            if (demo) {
                // Clear current queue and add demo behaviors
                clearQueue();
                demo.behaviors.forEach(behavior => {
                    addToBehaviorQueue(behavior);
                });

                console.log(`Started ${demo.name} with ${demo.behaviors.length} behaviors`);
                sendBehaviorCommand('demo_start', { type: demoType, demo: demo });
            }
        }

        // Display Update Functions
        function updateBehaviorStatusDisplay() {
            document.getElementById('currentBehavior').textContent = behaviorStatus.current;
            document.getElementById('behaviorProgress').style.width = behaviorStatus.progress + '%';
            document.getElementById('behaviorDuration').textContent =
                `${behaviorStatus.duration} / ${behaviorStatus.totalDuration}`;
        }

        function updateEnvironmentDisplay() {
            document.getElementById('peopleCount').textContent = environmentData.peopleCount;
            document.getElementById('motionLevel').textContent = environmentData.motionLevel;
            document.getElementById('noiseLevel').textContent = environmentData.noiseLevel;
        }

        function updateQueueDisplay() {
            const queueElement = document.getElementById('behaviorQueue');
            const countElement = document.getElementById('queueCount');

            countElement.textContent = `(${behaviorQueue.length})`;

            // CRITICAL XSS FIX: Replace innerHTML with safe DOM creation
            queueElement.innerHTML = ''; // Clear first

            if (behaviorQueue.length === 0) {
                const emptyDiv = createSafeElement('div', { className: 'queue-empty' }, 'No behaviors queued');
                queueElement.appendChild(emptyDiv);
            } else {
                behaviorQueue.forEach((behavior, index) => {
                    // Create queue item container safely
                    const queueItem = createSafeElement('div', {
                        className: 'queue-item',
                        style: {
                            background: 'rgba(59, 130, 246, 0.1)',
                            border: '1px solid #3b82f6',
                            borderRadius: '6px',
                            padding: '8px 12px',
                            marginBottom: '6px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }
                    });

                    // Create info container
                    const infoDiv = document.createElement('div');

                    // Sanitize behavior name (CRITICAL - prevents XSS injection)
                    const nameStrong = createSafeElement('strong', {
                        style: { color: '#3b82f6' }
                    }, behavior.name); // Safe: textContent used internally

                    const detailsSmall = createSafeElement('small', {
                        style: { display: 'block', color: '#9ca3af' }
                    }, `${formatDuration(behavior.duration)} ‚Ä¢ ${behavior.timestamp}`);

                    infoDiv.appendChild(nameStrong);
                    infoDiv.appendChild(detailsSmall);

                    // Create remove button
                    const removeBtn = createSafeElement('button', {
                        style: {
                            background: '#dc2626',
                            color: 'white',
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            cursor: 'pointer',
                            fontSize: '0.8rem'
                        }
                    }, 'Remove');
                    removeBtn.onclick = () => removeBehaviorFromQueue(index);

                    queueItem.appendChild(infoDiv);
                    queueItem.appendChild(removeBtn);
                    queueElement.appendChild(queueItem);
                });
            }

            // Update queue status
            document.getElementById('behaviorQueueStatus').textContent = `${behaviorQueue.length} pending`;
        }

        function updateServoActivityDisplay(servoData) {
            if (servoData) {
                const servoDots = document.querySelectorAll('.servo-dot');
                servoDots.forEach((dot, index) => {
                    if (servoData.active && servoData.active.includes(index)) {
                        dot.classList.remove('idle');
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                        dot.classList.add('idle');
                    }
                });

                const activeCount = servoData.active ? servoData.active.length : 0;
                document.getElementById('activeServos').textContent = `${activeCount}/8`;
            }
        }

        function updateAudioStatusDisplay(audioData) {
            const audioActivity = document.getElementById('audioActivity');
            const audioQueue = document.getElementById('audioQueue');

            if (audioData) {
                // XSS FIX: Replace innerHTML with safe DOM creation
                audioActivity.innerHTML = ''; // Clear first

                if (audioData.current) {
                    const audioItem = createSafeElement('div', { className: 'audio-item' });
                    const currentSpan = createSafeElement('span', {
                        className: 'audio-current'
                    }, audioData.current); // Safe: textContent
                    const description = createSafeElement('small', {},
                        audioData.description || 'Playing...'); // Safe: textContent

                    audioItem.appendChild(currentSpan);
                    audioItem.appendChild(description);
                    audioActivity.appendChild(audioItem);
                } else {
                    const audioItem = createSafeElement('div', { className: 'audio-item' });
                    const currentSpan = createSafeElement('span', {
                        className: 'audio-current'
                    }, 'Ready');
                    const description = createSafeElement('small', {}, 'No active sounds');

                    audioItem.appendChild(currentSpan);
                    audioItem.appendChild(description);
                    audioActivity.appendChild(audioItem);
                }

                // XSS FIX: Use safe DOM creation for queue display
                audioQueue.innerHTML = ''; // Clear first
                if (audioData.queue && audioData.queue.length > 0) {
                    const queueSmall = createSafeElement('small', {},
                        `Queue: ${audioData.queue.length} sounds`);
                    audioQueue.appendChild(queueSmall);
                } else {
                    const queueEmpty = createSafeElement('small', {}, 'Queue: Empty');
                    audioQueue.appendChild(queueEmpty);
                }
            }
        }

        function updateCharacterRecognition(characters) {
            const charactersGrid = document.getElementById('detectedCharacters');

            // CRITICAL XSS FIX: Replace innerHTML with safe DOM creation
            charactersGrid.innerHTML = ''; // Clear first

            if (characters && characters.length > 0) {
                characters.forEach(character => {
                    // Create character card container safely
                    const card = createSafeElement('div', {
                        className: 'character-card',
                        style: {
                            background: 'rgba(34, 197, 94, 0.1)',
                            border: '1px solid #22c55e',
                            borderRadius: '8px',
                            padding: '12px',
                            textAlign: 'center'
                        }
                    });

                    // Sanitize emoji (prevent XSS in emoji field)
                    const emojiDiv = createSafeElement('div', {
                        style: { fontSize: '1.2rem', marginBottom: '6px' }
                    }, character.emoji || 'üë§'); // Safe: textContent

                    // Sanitize character name (CRITICAL - prevents XSS injection)
                    const nameStrong = createSafeElement('strong', {
                        style: { color: '#22c55e', display: 'block' }
                    }, character.name); // Safe: textContent

                    const confidenceSmall = createSafeElement('small', {
                        style: { color: '#9ca3af' }
                    }, `${Math.round(character.confidence * 100)}% confidence`);

                    // Sanitize reaction (prevents XSS in reaction field)
                    const reactionDiv = createSafeElement('div', {
                        style: { marginTop: '6px', fontSize: '0.8rem', color: '#f59e0b' }
                    }, `R2D2: ${character.reaction || 'Neutral'}`); // Safe: textContent

                    card.appendChild(emojiDiv);
                    card.appendChild(nameStrong);
                    card.appendChild(confidenceSmall);
                    card.appendChild(reactionDiv);
                    charactersGrid.appendChild(card);
                });
            } else {
                const placeholder = createSafeElement('div', {
                    className: 'character-placeholder'
                }, 'üë§ No characters detected');
                charactersGrid.appendChild(placeholder);
            }
        }

        // Helper Functions
        // ENHANCED Behavior Command with Validation and Error Handling
        function sendBehaviorCommand(command, data) {
            // Input validation and sanitization
            if (!validateBehaviorCommand(command, data)) {
                console.error('‚ùå Invalid behavior command parameters');
                showSystemAlert('Invalid behavior command rejected', 'warning');
                return false;
            }

            const connection = connectionManager.behavior;
            if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                try {
                    const message = {
                        type: 'behavior_command',
                        command: sanitizeString(command),
                        data: sanitizeObject(data),
                        timestamp: Date.now(),
                        source: 'enhanced_dashboard'
                    };

                    connection.ws.send(JSON.stringify(message));
                    console.log(`‚úÖ Behavior Command Sent: ${command}`);
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to send behavior command:', error);
                    showSystemAlert('Failed to send behavior command', 'error');
                    return false;
                }
            } else {
                console.warn('‚ö†Ô∏è Behavioral system not connected, command queued');
                showSystemAlert('Behavioral system offline - command queued', 'warning');
                return false;
            }
        }

        // Input validation for behavior commands
        function validateBehaviorCommand(command, data) {
            if (typeof command !== 'string' || command.length === 0 || command.length > 100) {
                return false;
            }

            // Check for potentially dangerous commands
            const dangerousPatterns = ['eval', 'function', 'script', '<', '>', 'javascript:', 'data:'];
            if (dangerousPatterns.some(pattern => command.toLowerCase().includes(pattern))) {
                console.error('Dangerous command pattern detected:', command);
                return false;
            }

            return true;
        }

        // String sanitization for security
        function sanitizeString(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/[<>"'&]/g, function(match) {
                const escapeMap = {
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '&': '&amp;'
                };
                return escapeMap[match];
            });
        }

        // Object sanitization for security
        function sanitizeObject(obj) {
            if (!obj || typeof obj !== 'object') return obj;

            const sanitized = {};
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const sanitizedKey = sanitizeString(key);
                    const value = obj[key];

                    if (typeof value === 'string') {
                        sanitized[sanitizedKey] = sanitizeString(value);
                    } else if (typeof value === 'number' && isFinite(value)) {
                        sanitized[sanitizedKey] = value;
                    } else if (typeof value === 'boolean') {
                        sanitized[sanitizedKey] = value;
                    } else if (typeof value === 'object') {
                        sanitized[sanitizedKey] = sanitizeObject(value);
                    }
                }
            }

            return sanitized;
        }

        function removeBehaviorFromQueue(index) {
            if (index >= 0 && index < behaviorQueue.length) {
                behaviorQueue.splice(index, 1);
                updateQueueDisplay();
                sendBehaviorCommand('queue_update', { queue: behaviorQueue });
            }
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateBehaviorStatus(status) {
            if (status.current) behaviorStatus.current = status.current;
            if (status.progress !== undefined) behaviorStatus.progress = status.progress;
            if (status.duration) behaviorStatus.duration = status.duration;
            if (status.totalDuration) behaviorStatus.totalDuration = status.totalDuration;

            updateBehaviorStatusDisplay();
        }

        function updateEnvironmentData(data) {
            if (data.motionLevel) environmentData.motionLevel = data.motionLevel;
            if (data.noiseLevel) environmentData.noiseLevel = data.noiseLevel;
            if (data.peopleCount !== undefined) environmentData.peopleCount = data.peopleCount;

            updateEnvironmentDisplay();
        }

        // ADVANCED System Management Functions
        function connectToAllSystems() {
            console.log('üîå Initiating connections to all R2D2 systems');

            // Stagger connections to prevent overwhelming the system
            setTimeout(() => connectToVisionSystem(), 100);
            setTimeout(() => connectToDashboard(), 300);
            setTimeout(() => connectToBehaviorSystem(), 500);
        }

        function initializeConnectionHealthMonitoring() {
            console.log('üíì Initializing connection health monitoring');

            // Reset all health metrics
            Object.keys(connectionHealth).forEach(system => {
                connectionHealth[system] = {
                    latency: 0,
                    lastHeartbeat: 0,
                    messagesReceived: 0,
                    errors: 0
                };
            });
        }

        function initializePerformanceMonitoring() {
            console.log('‚ö° Initializing performance monitoring');

            performanceMetrics = {
                frameCount: 0,
                lastFrameTime: performance.now(),
                averageFPS: 0,
                messageQueue: [],
                renderTime: 0
            };
        }

        function initializeSecurityProtection() {
            console.log('üõ°Ô∏è Initializing security protection');

            // Add CSP violation detection
            document.addEventListener('securitypolicyviolation', (e) => {
                console.warn('üîí Security Policy Violation:', e.violatedDirective);
                showSystemAlert('Security policy violation detected', 'warning');
            });

            // Add basic XSS protection
            window.addEventListener('error', (e) => {
                if (e.message && e.message.includes('script')) {
                    console.error('üö® Potential security issue detected:', e.message);
                    showSystemAlert('Potential security issue detected', 'critical');
                }
            });
        }

        function startSystemMonitoring() {
            console.log('üìä Starting system monitoring intervals');

            // MEMORY LEAK FIX: Use ManagedInterval for automatic cleanup
            // Connection health monitoring every 5 seconds
            const healthInterval = new ManagedInterval(
                monitorConnectionHealth,
                5000,
                'connectionHealth'
            );
            healthInterval.start();
            resourceManager.registerInterval('connectionHealth', healthInterval);

            // Performance monitoring every 2 seconds
            const performanceInterval = new ManagedInterval(
                updatePerformanceDisplay,
                2000,
                'performance'
            );
            performanceInterval.start();
            resourceManager.registerInterval('performance', performanceInterval);

            // System status updates every 3 seconds
            const statusInterval = new ManagedInterval(
                updateSystemStatus,
                3000,
                'systemStatus'
            );
            statusInterval.start();
            resourceManager.registerInterval('systemStatus', statusInterval);
        }

        function monitorConnectionHealth() {
            const now = Date.now();

            Object.keys(connectionHealth).forEach(system => {
                const health = connectionHealth[system];
                const connection = connectionManager[system];

                // Check for stale connections (no heartbeat in 30 seconds)
                if (connection.status === 'connected' && (now - health.lastHeartbeat) > 30000) {
                    console.warn(`üíî ${system} connection appears stale, forcing reconnection`);

                    if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                        connection.ws.close(1000, 'Health check timeout');
                    }
                }
            });
        }

        function updatePerformanceMetrics(type, processingTime) {
            performanceMetrics.messageQueue.push({ type, time: processingTime, timestamp: Date.now() });

            // Keep only last 100 metrics
            if (performanceMetrics.messageQueue.length > 100) {
                performanceMetrics.messageQueue.shift();
            }

            // Update average response time
            const averageTime = performanceMetrics.messageQueue.reduce((sum, metric) => sum + metric.time, 0) / performanceMetrics.messageQueue.length;
            document.getElementById('responseTime').textContent = averageTime.toFixed(0) + 'ms';
        }

        function updatePerformanceDisplay() {
            // Update FPS calculation
            const now = performance.now();
            const deltaTime = now - performanceMetrics.lastFrameTime;

            if (deltaTime > 0) {
                const currentFPS = 1000 / deltaTime;
                performanceMetrics.averageFPS = (performanceMetrics.averageFPS * 0.9) + (currentFPS * 0.1);
                document.getElementById('systemFPS').textContent = performanceMetrics.averageFPS.toFixed(1);
            }

            performanceMetrics.lastFrameTime = now;
        }

        function updateSystemStatus() {
            // Update connection status displays
            const overallHealth = calculateOverallSystemHealth();
            updateConnectionStatusIndicators(overallHealth);
        }

        function calculateOverallSystemHealth() {
            const systems = Object.keys(connectionManager);
            const connectedSystems = systems.filter(system => connectionManager[system].status === 'connected');

            return {
                connected: connectedSystems.length,
                total: systems.length,
                percentage: Math.round((connectedSystems.length / systems.length) * 100)
            };
        }

        function updateConnectionStatusIndicators(health) {
            const statusElement = document.getElementById('connectionStatus');

            if (health.percentage === 100) {
                statusElement.textContent = 'All Systems Online';
                statusElement.className = 'connection-status connected';
            } else if (health.percentage >= 66) {
                statusElement.textContent = `${health.connected}/${health.total} Systems Online`;
                statusElement.className = 'connection-status connected';
            } else if (health.percentage >= 33) {
                statusElement.textContent = `${health.connected}/${health.total} Systems Online`;
                statusElement.className = 'connection-status';
                statusElement.style.background = '#f59e0b'; // Warning color
            } else {
                statusElement.textContent = 'Systems Offline';
                statusElement.className = 'connection-status';
            }
        }

        function showSystemAlert(message, level = 'info') {
            console.log(`üö® System Alert [${level.toUpperCase()}]: ${message}`);

            // You could implement toast notifications here
            // For now, we'll use console logging and optionally show visual feedback

            if (level === 'critical') {
                // Flash the emergency stop button
                const emergencyBtn = document.querySelector('.emergency-stop button');
                if (emergencyBtn) {
                    emergencyBtn.style.animation = 'pulse 0.5s infinite';
                    setTimeout(() => {
                        emergencyBtn.style.animation = 'pulse 2s infinite';
                    }, 5000);
                }
            }
        }

        // Enhanced command sending with retry logic
        function sendVisionCommand(command, data) {
            const connection = connectionManager.vision;
            if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'command',
                    command: command,
                    data: data,
                    timestamp: Date.now()
                };
                connection.ws.send(JSON.stringify(message));
                return true;
            } else {
                console.warn('‚ö†Ô∏è Vision system not connected, command queued for retry');
                return false;
            }
        }

        function sendDashboardCommand(command, data) {
            const connection = connectionManager.dashboard;
            if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'command',
                    command: command,
                    data: data,
                    timestamp: Date.now()
                };
                connection.ws.send(JSON.stringify(message));
                return true;
            } else {
                console.warn('‚ö†Ô∏è Dashboard system not connected, command queued for retry');
                return false;
            }
        }

        // ENHANCED Page Load with Quality Controls
        window.addEventListener('load', function() {
            console.log('üéØ R2D2 Enhanced Dashboard Loading with Quality Controls');
            initialize();
        });

        // Graceful shutdown handling
        window.addEventListener('beforeunload', function(e) {
            console.log('üîå Gracefully closing all WebSocket connections');

            Object.keys(connectionManager).forEach(system => {
                const connection = connectionManager[system];
                if (connection.ws && connection.ws.readyState === WebSocket.OPEN) {
                    connection.ws.close(1000, 'Page unload');
                }
                if (connection.reconnectInterval) {
                    clearTimeout(connection.reconnectInterval);
                }
            });
        });
    </script>
</body>
</html>